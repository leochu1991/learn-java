[TOC]

#### `jvm` 参数

| **性能选项**                   |                             |                                          |
| -------------------------- | --------------------------- | ---------------------------------------- |
| 选项与默认值                     | 默认值与限制                      | 描述                                       |
| -Xms                       | 初始堆大小                       | 默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制. |
| -Xmx                       | 最大堆大小                       | 默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制.注意：此处的大小是（eden+ 2 survivor space).与jmap -heap中显示的New gen是不同的。整个堆大小=年轻代大小 + 年老代大小 + 持久代大小. |
| -Xmn                       | 年轻代大小(1.4or later)          | 增大年轻代后,将会减小年老代大小.此值对系统性能影响较大,Sun官方推荐配置为整个堆的3/8 |
| -Xss                       | 每个线程的堆栈大小                   | JDK5.0以后每个线程堆栈大小为1M,以前每个线程堆栈大小为256K.更具应用的线程所需内存大小进行 调整.在相同物理内存下,减小这个值能生成更多的线程.但是操作系统对一个进程内的线程数还是有限制的,不能无限生成,经验值在3000~5000左右一般小的应用， 如果栈不是很深， 应该是128k够用的 大的应用建议使用256k。这个选项对性能影响比较大，需要严格的测试。（校长）和threadstacksize选项解释很类似,官方文档似乎没有解释,在论坛中有这样一句话:"”-Xss is translated in a VM flag named ThreadStackSize”一般设置这个值就可以了。 |
| -XX:MaxTenuringThreshold   | 垃圾最大年龄                      | 如果设置为0的话,则年轻代对象不经过Survivor区,直接进入年老代. 对于年老代比较多的应用,可以提高效率.如果将此值设置为一个较大值,则年轻代对象会在Survivor区进行多次复制,这样可以增加对象再年轻代的存活 时间,增加在年轻代即被回收的概率该参数只有在串行GC时才有效. |
| -XX:MaxHeapFreeRatio=70    | 70                          | GC后，如果发现空闲堆内存占到整个预估堆内存的70%，则收缩堆内存预估最大值。  |
| -XX:NewSize                | 设置年轻代大小(for 1.3/1.4)        |                                          |
| -XX:MaxNewSize=size        | 1.3.1 Sparc: 32m            | 新生代占整个堆内存的最大值。                           |
| -XX:MaxPermSize=64m        | 5.0以后: 64 bit VMs会增大预设值的30% | Perm占整个堆内存的最大值。                          |
| -XX:MinHeapFreeRatio=40    | 40                          | GC后，如果发现空闲堆内存占到整个预估堆内存的40%，则放大堆内存的预估最大值，但不超过固定最大值。 |
| -XX:NewRatio=2             | Sparc -client: 8            | 新生代和年老代的堆内存占用比例。这里的2表示，新生代占最大堆内存的1/2。也就是和年老代平分堆的占用。 |
| -XX:NewSize=2.125m         | 5.0以后: 64 bit Vms会增大预设值的30% | 新生代预估堆内存占用的默认值。(什么是预估堆内存？见 -XX:MaxHeapFreeRatio 处的描述) |
| -XX:SurvivorRatio=8        | Solaris amd64: 6            | Eden与Survivor的占用比例。这里的8表示，一个survivor区占用 1/8 的新生代内存，因为survivor有2个，所以是 2/8，那么Eden的占比为 6/8。 |
| -XX:TargetSurvivorRatio=50 | 50                          | 实际使用的survivor空间大小占比。默认是50%，最高90%。        |
| -XX:ThreadStackSize=512    | Sparc: 512                  | 线程堆栈大小                                   |
| -XX:-UseParallelGC         | 默认不启用，-server时启用            | 策略为新生代使用并行清除，年老代使用单线程Mark-Sweep-Compact清除的垃圾收集器。 |
| -XX:-UseParallelOldGC      | 默认不启用                       | 策略为老年代和新生代都使用并行清除的垃圾收集器。                 |
| -XX:-UseSerialGC           | 默认不启用，-client时启用            | 使用串行垃圾收集器。                               |

 #### 垃圾如何确认

+ 引用计数法：给对象添加一个引用计数器，当一个地方引用它时，计数器加1；当引用失效时，计数器减1，任何时刻引用计数器为0的对象就不能再使用。==缺点== ：难解决对象间的循环引用问题（A引用B，B引用A）。

+ 可达性分析算法：通过以一系列称为 `GC Roots` 的对象为开始结点，向下搜索，走过的路径称为引用链，当一个对象到 `GC Roots` 没有任何引用链时，证明该对象不可用。

  可作为 `GC Roots` 对象的有：

  + 虚拟机栈（栈帧中本地变量表）中引用的对象
  + 方法区中类静态属性引用的对象
  + 方法区中常量引用的对象
  + 本地方法栈中引用的对象

共同点：判断对象存活都与对象的引用有关

四种引用：

+ 强引用(`Strong Reference`)：类似 `Object object = new Object()` ，强引用存在，垃圾回收器不会回收被引用的对象。
+ 软引用(`Soft Reference`)：描述有用但非必需的对象，内存不足时会进行回收。
+ 弱引用(`Weak Reference`)：描述非必需对象，比软引用更弱，在下一次垃圾回收时，无论内存是否足够都会被回收。
+ 虚引用(`Phantom Reference`)：最弱的引用，对对象的存活时间没有影响，也不能通过虚引用找到对象实例，为对象设置虚引用的作用是在对象被垃圾回收时会收到一个系统通知。

#### 垃圾如何被回收——两次标记

+ 第一次标记：对象在进行可达性分析后，如果没有与 `GC Roots` 相连接的引用链，则进行第一次标记及筛选，看是否需要执行 `finalize()` 方法，若：

  + 对象没有重写 `finalize()` 方法
  + `finalize()` 方法已经被虚拟机执行过

  则 ==不== 需要进行筛选。

+ 若需要执行 `finalize()` 方法，则将对象加入 `F-Queue` 队列，并由虚拟机建立 `finalizer` 线程去执行 `finalize` 方法，不会等待执行结束（防止执行缓慢或死循环，其它对象无法被回收）。

+ `finalize()` 方法执行完之后，垃圾回收器会对 `F-Queue` 中的对象进行第二次标记，若对象仍未与引用链上的对象进行关联，则会被回收。若要避免回收，需要在执行 `finalize()` 方法过程中将对象与任一引用链上的对象关联，如将自己(`this`)赋值给某个类变量或某个对象的成员变量即可 。

#### 垃圾回收算法

+ 标记-清除算法
  + 分为“标记”和“清除”两个阶段
  + 缺点
    + “标记”和”清除“的过程效率不高
    + 空间问题，回收过程中产生大量不连续的内存碎片，内存碎片太多导致分配较大对象时因无法找到连续足够的内存空间而进行下一次垃圾回收
+ 复制算法
  + 将内存分为容量相等的两块，一块内存用完时，将存活对象复制到另一块内存上，然后将已使用的内存一次清理掉，不考虑内存碎片，只需移动堆顶指针，简单高效
  + 缺点：内存缩小为原来的一半
+ 标记-整理算法
  + 复制算法在对象存活时间较长时需要进行较多的复制，效率变低，老年代中对象可能100%存活，不能选用，需要在”标记“-”清除“的基础上将存活对象向边界移动，清理掉边界以外的内存
+ 分代收集算法
  + 根据对象存活周期不同，将内存分为几块，`java` 堆分成新生代和老生代，新生代存活对象少，采用复制算法，老生代对象存活率高，没有额外空间存储存活对象，采用标记-清除算法、标记-整理算法
  + 新生代：存储新创建的对象，分为 `Eden`，`From`，`To`，采用复制算法
  + 老年代：存储存活时间长的对象，在堆中多次垃圾回收仍然存活的对象，放入老年代，采用标记-清除算法或标记-整理算法 
  + 永久代：方法区的实现，`jdk1.8` 已移除，采用与堆不相干的元空间(`Metaspace`)，参数为`-XX:MaxMetaspaceSize`

#### `HotSpot` 回收过程

`HotSpot` 虚拟机通过可达性分析判断对象是否存活，存在以下问题：

+ `GC Roots`节点主要在全局性引用（常量、类静态变量）与执行上下文（栈帧中的本地变量表）中，逐个检查引用，会消耗很多时间。
+ `GC` 停顿，可达性分析需确保在一致性的快照中进行，即分析过程中对象引用关系不会在不断变化，这会导致 `GC` 过程中必须停顿所有 `Java`执行线程。
+ 虚拟机使用准确式 `GC`，虚拟机使用 `OopMap` 的数据结构在类加载时和 `JIT` 编译过程中，在特定位置记录栈中和寄存器中哪些位置是引用（记录偏移量），这些特定位置即为安全点(`Safepoint`)，程序只有在安全点才能停顿，然后开始垃圾回收。
+ 采用主动式中断，当 `GC` 需要中断线程时，在安全点和创建对象分配内存的地方设置标志，各线程执行时主动去轮询这个标志，发现中断标志为真就中断挂起。
+ 若程序不执行，即线程阻塞，就需要在安全区域(`Safe Region`)内执行 `GC` ，安全区域是引用关系不会发生变化的一段代码区域，线程在安全区域中时可以直接执行 `GC`，若出安全区域，需等 `GC` 过程完成。

#### 垃圾回收器

+ 新生代：
  + `Serial` 回收器：串行回收器，单线程，简单高效
  + `ParNew` 回收器：`Serial` 回收器的多线程版本
  + `Parallel Scavenge` 回收器：复制算法并行多线程回收器，关注吞吐量，即 `cpu` 执行效率高，而不是停顿时间短（交互体验好）
+ 老年代：
  + `Serial Old` 回收器：`Serial` 回收器的老年代版本，单线程，使用标记-整理算法
  + `Parallel Old` 回收器：`Parallel Scavenge` 回收器的老年代版本，多线程，使用标记-整理算法
  + `CMS` 回收器：`Concurrent Mark Sweep` ，关注最短停顿时间，使用标记-清除算法
    + 初始标记(`CMS initial mark`)：标记 `GC Roots` 能直接关联到的对象，速度快，需要 `Stop The World`
    + 并发标记(`CMS concurrent mark`)：进行 `GC Roots` 的 `Tracing` 过程
    + 重新标记(`CMS remark`)：修正并发标记阶段（`CMS` 回收器与用户线程并发执行）对象标记发生变化的标记记录，需要 `Stop The World`
    + 并发清除(`CMS concurrent sweep`)
    + ==缺点==：
      + `CMS` 回收器对 `cpu` 敏感，并发导致应用程序变慢，吞吐量降低
      + 无法处理浮动垃圾，即并发清除过程中用户线程仍然运行，会产生新的垃圾
      + 空间碎片，使用标记-清除算法，当无法为大对象分配连续足够的空间时会触发 `Full GC`
+ `G1`回收器：将整个堆分成大小相等的独立区域 `Region` ，具有以下优点：
  + 并发与并行
  + 分代回收
  + 使用标记-整理算法，没有内存碎片
  + 可预测的时间停顿（优先级区域回收）
    + 避免整个堆全区域进行垃圾回收，而是跟踪各区域的垃圾（获得垃圾回收的空间大小和回收时间），建立一个优先列表，每次在有限的收集时间内，优先回收价值最大的区域，即 (`Garbage-First`) 
  + 虚拟机在每个区域建立相关联的 `Remembered Set` ，记录该区域的引用对象，垃圾回收时在 `GC Roots` 添加 `Remembered Set` ，避免全堆扫描
  + 回收过程：
    + 初始标记(`Initial Marking`)：标记 `GC Roots` 能直接关联到的对象，需要停顿线程
    + 并发标记(`Concurrent Marking`)：从 `GC Roots` 开始进行可达性分析，找出存活对象，耗时长，并发执行
    + 最终标记(`Final Marking`)：修正并发标记阶段因用户线程执行导致对象记录发生变化的记录，记录在线程的 `Remembered Set Logs` 中，合并到 `Remembered Set` ，需要停顿线程，并行执行
    + 筛选回收(`Live Data Counting And Evacuation`)：根据优先级回收各区域，并行执行
+ 两种 `GC`
  + `Minor GC`：新生代 `GC` ，发生频繁，新生代对象存活时间短，回收速度快
  + `Major/Full GC`：老年代 `GC`，出现一次 `Major GC` ，至少伴随一次 `Minor GC`，速度比 `Minor GC` 慢10倍以上

#### 参考文章

1 [《深入理解Java虚拟机》——垃圾收集器与内存分配策略问题](https://www.jianshu.com/p/cd9972bfbe3d)

2 [从实际案例聊聊Java应用的GC优化](https://tech.meituan.com/jvm_optimize.html)